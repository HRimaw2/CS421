 
GRADE REPORT
------------

Student: sak2
Assignment: ml5


--- --- --- Score report: --- --- ---

 --- Parser section compiled; points deducted ---
 --- LL section compiled; points deducted ---
 --- Terminals section passed ---

 -- Console output: --

Parser:
  parser test realIdent: [OK, passed 1 tests]
  parser test tokenLine: [OK, passed 1 tests]
  parser test epsilonLine: [Failed]
*** Failed! Falsifiable (after 1 test): 
(used seed 597267232009355289)

         Properties  Total      
 Passed  2           2          
 Failed  1           1          
 Total   3           3          

Calls to isLL on LL grammars:
  isLL test on ll1: [OK, passed 1 tests]
  isLL test on ll3: [Failed]
*** Failed! Falsifiable (after 1 test): 
(used seed 1638365678202057295)
Calls to isLL on left-recursive grammars:
  isLL test on rec1: [OK, passed 1 tests]
  isLL test on rec2: [OK, passed 1 tests]
  isLL test on rec4: [OK, passed 1 tests]
Calls to isLL on common prefix grammars:
  isLL test on compre 1: [Failed]
*** Failed! Falsifiable (after 1 test): 
(used seed 4076132458847362789)
  isLL test on compre 2: [OK, passed 1 tests]
  isLL test on compre 4: [OK, passed 1 tests]

         Properties  Total      
 Passed  6           6          
 Failed  2           2          
 Total   8           8          

Terminals:
  parser test terminals: [OK, passed 1 tests]

         Properties  Total      
 Passed  1           1          
 Failed  0           0          
 Total   1           1          

 ============= SUMMARY: =============
Parser section: 2 / 3
LL section: 6 / 8
 (Best will be recorded.)
Terminals section: +10, capped at 100.

Score: 85 / 100



--- --- --- Student submission: --- --- ---


{-# LANGUAGE DeriveGeneric #-}

module Lib where

import qualified Data.HashMap.Strict as H
import qualified Data.HashSet as S
import Data.Functor.Identity

import Text.ParserCombinators.Parsec hiding (Parser)
import Text.Parsec.Prim (ParsecT)
import Text.Parsec.Char

import GHC.Generics (Generic)
import Data.Hashable
import Data.List (intercalate)
import Debug.Trace

-- The Types

data Symbol = Symbol String
           | Epsilon
   deriving (Eq,Generic)

data Production = Production String [[Symbol]]
   deriving Eq

data Grammar = Grammar [Production] (S.HashSet Symbol) (S.HashSet Symbol)

-- ε caused problems...
instance Show Symbol where
  show (Symbol s) = s
  show Epsilon = "eps"

instance Show Production where
  show (Production s xx) = aux header xx
    where header = s ++ " -> "
          padding = replicate (length header - 2) ' ' ++ "| "
          aux _ [] = ""
          aux prefix (x:xs) = prefix ++ unwords (map show x) ++ "\n" ++ aux padding xs

instance Hashable Symbol

showGrammar :: Grammar -> String
showGrammar (Grammar xx _ _) = concatMap show xx

instance Show Grammar where
  show (Grammar xx terms nonterms) =
    concatMap show xx ++ "\nTerminal Symbols: " ++
      show terms ++ "\nNonterminal Symbols: " ++
      show nonterms

-- The Parser

-- Pretty name for Parser types
type Parser = ParsecT String () Identity

-- for testing a parser directly
run :: Parser a -> String -> a
run p s =
    case parse p "<stdin>" s of
        Right x -> x
        Left x  -> error $ show x

-- inlinews - parses spaces and tabs but not newlines
inlinews :: Parser String
inlinews = many (oneOf " \t") <?> "whitespace"

-- stringws - parses a string and consumes trailing whitespace
stringws :: String -> Parser String
stringws s = do _ <- string s
                _ <- inlinews
                return s

-- ident - parse a non-epsilon identifier, at least one upper or lowercase letter
ident :: Parser String
ident = do i <- try $ do ii <- many1 (oneOf (['a'..'z'] ++ ['A'..'Z'])) <?> "an identifier"
                         if ii == "eps" then fail "eps not expected" else return ii
           _ <- inlinews
           return i

-- =====================================
-- -------------------------------------
-- ML PROBLEM: realIdent
-- -------------------------------------

-- realIdent - like ident, but returns it as a Symbol
realIdent :: Parser Symbol
realIdent = do s <- ident <?> "an identifier"
               _ <- inlinews
               return (Symbol s)

               -- this monadic code isn't correct; fix it

-- We recommend that you try to solve these ML problems in order. -course staff

-- - - - - - - - - - - - - - - - - - - -
-- =====================================

-- epsilon - parse "eps" or "ε" returning Epsilon
epsilon :: Parser Symbol
epsilon = do _ <- (string "ε" <|> string "eps") <?> "an epsilon"
             _ <- inlinews
             return Epsilon

-- =====================================
-- -------------------------------------
-- ML PROBLEM: epsilonLine
-- -------------------------------------

-- epsilonLine - parse a production that only has an epsilon in it.
epsilonLine :: Parser [Symbol]
epsilonLine = do _ <- many epsilon
                 _ <- endOfLine
                 return [Epsilon]

               -- this monadic code isn't correct; fix it

-- - - - - - - - - - - - - - - - - - - -
-- =====================================

-- =====================================
-- -------------------------------------
-- ML PROBLEM: tokenLine
-- -------------------------------------

-- tokenLine - parse a production that is not an epsilon.
tokenLine :: Parser [Symbol]
tokenLine = do s <- many1 realIdent
               _ <- endOfLine
               return s

-- this monadic code isn't correct; fix it

-- - - - - - - - - - - - - - - - - - - -
-- =====================================

-- initialProduction - parse an initial production line
initialProduction :: Parser (String,[Symbol])
initialProduction = do s <- ident
                       _ <- stringws "->"
                       tt <- epsilonLine <|> tokenLine
                       return (s,tt)

continueProduction :: Parser [Symbol]
continueProduction = do try $ do _ <- inlinews
                                 stringws "|"
                        res <- epsilonLine <|> tokenLine
                        return res

production :: Parser Production
production = do (s,x) <- initialProduction
                xs <- many continueProduction
                return (Production s (x:xs))

grammar :: Parser Grammar
grammar = do p <- many1 production
             return (Grammar p (terminals p) (nonTerminals p))

p0 = "S -> x S y\n | z q Y\n"
p1 = "S -> x S y\n | z q Y\nY -> x Y y \n| eps\n"

-- Some analysis

nonTerminals :: [Production] -> S.HashSet Symbol
nonTerminals g = S.fromList $ map (\ (Production s _) -> Symbol s) g

symbols :: [Production] -> S.HashSet Symbol
symbols [] = S.empty
symbols ((Production s xx):ps) = S.union (S.insert (Symbol s) $ S.fromList (concat xx)) (symbols ps)

-- =====================================
-- -------------------------------------
-- ML PROBLEM: terminals
-- -------------------------------------

terminals :: [Production] -> S.HashSet Symbol
terminals g = S.difference (symbols g) (nonTerminals g)

-- - - - - - - - - - - - - - - - - - - -
-- =====================================

fix f x =
  if x == result
    then x
    else fix f result
  where result = f x

-- getFirstSet grammar
-- calculate the first sets of the nonterminals in a grammar
getFirstSet :: Grammar -> H.HashMap Symbol (S.HashSet Symbol)
getFirstSet (Grammar psets terminals nonterminals) =
    fix (aux psets) initial
     where initial :: H.HashMap Symbol (S.HashSet Symbol)
           initial = H.fromList (zip (S.toList nonterminals) (repeat S.empty))
           aux [] fs = fs
           aux (Production s stuff : ps) fs =
             let Just oldfs = H.lookup (Symbol s) fs
                 newfs = foldr (\pline set ->
                                   S.union set
                                   (first fs pline))
                         oldfs stuff
              in aux ps $ H.insert (Symbol s) newfs fs

-- first fs symbols
-- return the first set of a set of symbols
first :: H.HashMap Symbol (S.HashSet Symbol) -> [Symbol] -> S.HashSet Symbol
first fs [] = S.singleton Epsilon
first fs (x:xs) =
  let s1 = S.union (S.singleton x) $ H.lookupDefault S.empty x fs
   in if S.member Epsilon s1
         then S.union (S.delete Epsilon s1) (first fs xs)
         else s1

-- =====================================
-- -------------------------------------
-- ML PROBLEM: isLL
-- -------------------------------------

-- Again, we REALLY recommend that you try to solve the ML problems in order.
-- Try the parser ones before you try this one.
--  -course staff

-- Remember the two properties we require for a grammar to be LL.
-- Recall some of the useful functions in libraries S and H.
--   union, insert, delete, singleton, lookup, lookupDefault,
--   empty, member, difference, fromList, toList

-- isLL
isLL :: Grammar -> Bool
isLL g = 
    let  fs = (getFirstSet g)
         (Grammar psets terminals nonterminals) = g
    in not(isLeftRecursive psets) && not(hasCommonPrefix psets fs) 

hasCommonPrefix ((Production s xx):ps) fs =
    if (lookFwd s (H.keys fs) fs)
       then True
       else if not(null(ps))
            then False || (hasCommonPrefix ps fs)
            else False 

lookFwd k [] fs = False
lookFwd k (x:xs) fs = 
    let st = H.lookupDefault S.empty x fs
    in if(S.size(S.intersection (S.singleton(Symbol k)) (st)) > 0)
         then True
         else if not(null(xs))
            then False || (lookFwd k xs fs)
            else False

isLeftRecursive ((Production s xx):ps) =
    if (S.size(S.intersection (S.singleton(Symbol s)) (S.fromList(concat xx))) > 0) 
       then True
       else if not(null(ps))
            then False || (isLeftRecursive ps)
            else False  

-- - - - - - - - - - - - - - - - - - - -
-- =====================================



